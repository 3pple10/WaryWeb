<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>WaryWEB - Reversi (Othello)</title>
  <!-- Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Google Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700;900&display=swap" rel="stylesheet">
  <!-- Lucide Icons -->
  <script src="https://unpkg.com/lucide@latest"></script>
  <style>
    body {
        font-family: 'Inter', sans-serif;
        background-color: #0a0a0a;
        background-image: radial-gradient(circle at top right, rgba(255, 165, 0, 0.15), transparent 40%),
                          radial-gradient(circle at bottom left, rgba(0, 200, 255, 0.15), transparent 50%);
    }

    .card-glass {
      background: rgba(23, 23, 23, 0.65);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .nav-link {
      position: relative;
    }
    .nav-link::after {
      content: "";
      position: absolute;
      width: 0%;
      height: 2px;
      left: 0;
      bottom: -3px;
      background: #fff;
      transition: 0.3s;
    }
    .nav-link:hover::after {
      width: 100%;
    }

    /* Mobile menu styles */
    .mobile-menu {
      transform: translateX(100%);
      transition: transform 0.3s ease-in-out;
    }
    .mobile-menu.active {
      transform: translateX(0);
    }

    /* Prevent horizontal scrolling */
    html, body {
        overflow-x: hidden;
    }

    .grid-container {
        display: grid;
        grid-template-columns: repeat(8, 1fr);
        grid-template-rows: repeat(8, 1fr);
        gap: 2px;
        aspect-ratio: 1 / 1;
        width: 100%;
        max-width: 500px;
    }

    .grid-cell {
        background-color: #166534; /* Dark green for the board */
        position: relative;
        cursor: pointer;
        border-radius: 4px;
        transition: background-color 0.3s ease;
    }

    .grid-cell:hover:not(.occupied):not(.disabled) {
        background-color: #1a8f46;
    }
    .grid-cell.occupied {
        cursor: default;
    }
    .grid-cell.disabled {
        cursor: not-allowed;
        opacity: 0.5;
    }
    .grid-cell.hint {
        background-color: #3b82f6; /* A clear color for hints */
    }
    .grid-cell.hint-hard {
        background-color: #f59e0b; /* A gold/yellow color for hard hints */
    }

    .disc {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 80%;
        height: 80%;
        border-radius: 50%;
        transition: transform 0.5s ease-in-out;
        box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
    }

    .disc.black {
        background-color: #000;
    }

    .disc.white {
        background-color: #fff;
    }

    .flipped-from-black {
        animation: flip-to-white 0.5s forwards;
    }

    .flipped-from-white {
        animation: flip-to-black 0.5s forwards;
    }

    @keyframes flip-to-white {
        0% { transform: rotateY(0deg) translate(-50%, -50%); background-color: #000; }
        50% { transform: rotateY(90deg) translate(-50%, -50%); background-color: #000; }
        51% { background-color: #fff; }
        100% { transform: rotateY(180deg) translate(-50%, -50%); background-color: #fff; }
    }

    @keyframes flip-to-black {
        0% { transform: rotateY(0deg) translate(-50%, -50%); background-color: #fff; }
        50% { transform: rotateY(90deg) translate(-50%, -50%); background-color: #fff; }
        51% { background-color: #000; }
        100% { transform: rotateY(180deg) translate(-50%, -50%); background-color: #000; }
    }

    .ai-move-highlight {
        animation: pulse-border 1.5s infinite;
    }

    @keyframes pulse-border {
        0% { box-shadow: 0 0 0 0 rgba(255, 255, 255, 0.7); }
        70% { box-shadow: 0 0 0 10px rgba(255, 255, 255, 0); }
        100% { box-shadow: 0 0 0 0 rgba(255, 255, 255, 0); }
    }
  </style>
</head>
<body class="text-white">

<!-- Header -->
<header class="fixed top-0 left-0 w-full bg-black/80 backdrop-blur-md border-b border-gray-800 z-50">
  <div class="max-w-6xl mx-auto flex items-center justify-between px-4 py-3 sm:px-6 sm:py-4">
    <a href="index.html" class="text-xl sm:text-2xl font-black">WaryWEB</a>

    <nav class="hidden md:flex gap-6 lg:gap-8 text-gray-300">
      <a href="#" class="nav-link hover:text-white">Games</a>
      <a href="#" class="nav-link hover:text-white">Utilities</a>
      <a href="#" class="nav-link hover:text-white">About</a>
    </nav>

    <button id="mobile-menu-button" class="md:hidden p-2">
      <i data-lucide="menu" class="w-6 h-6"></i>
    </button>

    <div class="hidden sm:flex card-glass items-center gap-4 px-4 py-2 rounded-lg">
      <div id="clock" class="text-lg font-bold">10:59</div>
      <div class="border-l border-gray-600 h-6"></div>
      <div id="date" class="text-sm text-gray-300">Dec, 2025</div>
    </div>
  </div>

  <!-- Mobile Menu -->
  <div id="mobile-menu" class="mobile-menu fixed top-0 right-0 h-full w-64 bg-black/95 backdrop-blur-lg z-50 p-6 md:hidden">
    <div class="flex justify-between items-center mb-10">
      <h2 class="text-xl font-bold">Menu</h2>
      <button id="close-menu" class="p-2">
        <i data-lucide="x" class="w-6 h-6"></i>
      </button>
    </div>
    <nav class="flex flex-col gap-6 text-lg">
      <a href="#" class="nav-link hover:text-white py-2">Games</a>
      <a href="#" class="nav-link hover:text-white py-2">Utilities</a>
      <a href="#" class="nav-link hover:text-white py-2">About</a>
    </nav>
    <div class="mt-10 pt-6 border-t border-gray-700">
      <div class="flex items-center gap-3">
        <i data-lucide="clock" class="w-5 h-5"></i>
        <div id="mobile-clock" class="font-medium">10:59</div>
      </div>
      <div class="flex items-center gap-3 mt-2">
        <i data-lucide="calendar" class="w-5 h-5"></i>
        <div id="mobile-date" class="text-gray-300">Dec, 2025</div>
      </div>
    </div>
  </div>
</header>

<!-- Small Mobile Time/Date -->
<div class="sm:hidden fixed top-16 right-4 z-40">
  <div class="card-glass px-3 py-1 rounded-lg text-sm flex items-center gap-2">
    <span id="mobile-time-small" class="font-medium">10:59</span>
    <span class="text-gray-300">â€¢</span>
    <span id="mobile-date-small">Dec, 2025</span>
  </div>
</div>

<!-- Reversi Game Section -->
<section id="reversi-game-section" class="py-24 px-6 min-h-screen flex flex-col items-center justify-center">
  <div class="max-w-6xl w-full mx-auto text-center mb-8">
    <h3 id="game-title" class="text-4xl sm:text-5xl font-extrabold tracking-tight">Reversi</h3>
    <p id="game-message" class="text-lg sm:text-xl text-gray-400 mt-2">Black starts! Place a disc to capture your opponent's.</p>
  </div>

  <div class="max-w-5xl w-full mx-auto p-6 md:p-12 card-glass rounded-2xl flex flex-col items-center">
    <div class="flex justify-between items-center w-full max-w-[500px] mb-6">
      <div class="flex items-center gap-2">
        <span class="disc black w-6 h-6"></span>
        <p class="text-xl font-bold">Black: <span id="black-score">2</span></p>
      </div>
      <div class="flex items-center gap-2">
        <span class="disc white w-6 h-6"></span>
        <p class="text-xl font-bold">White: <span id="white-score">2</span></p>
      </div>
    </div>

    <div id="game-board" class="grid-container rounded-lg overflow-hidden border-4 border-[#16a34a]"></div>

    <div class="flex flex-col sm:flex-row items-center gap-4 mt-6">
      <p class="text-sm">Game Mode:</p>
      <div class="flex items-center gap-4">
        <button id="pvp-mode" class="px-4 py-2 rounded-xl bg-green-700 text-white font-semibold transition-colors duration-200">Player vs Player</button>
        <button id="ai-mode" class="px-4 py-2 rounded-xl bg-purple-600 hover:bg-purple-700 text-white font-semibold transition-colors duration-200">Player vs AI</button>
      </div>
    </div>

    <div id="difficulty-options" class="flex flex-col sm:flex-row items-center gap-4 mt-4 hidden">
      <p class="text-sm">AI Difficulty:</p>
      <div class="flex items-center gap-4">
        <button id="easy-mode-btn" class="px-4 py-2 rounded-xl bg-gray-600 hover:bg-gray-700 text-white font-semibold transition-colors duration-200">Easy</button>
        <button id="hard-mode-btn" class="px-4 py-2 rounded-xl bg-red-700 text-white font-semibold transition-colors duration-200">Hard</button>
      </div>
    </div>

    <div id="hint-option" class="flex items-center gap-2 mt-4 hidden">
      <input type="checkbox" id="hint-toggle" class="form-checkbox h-5 w-5 text-blue-600 rounded">
      <label for="hint-toggle" class="text-gray-300">Show AI Hint</label>
    </div>

    <button id="reset-button" class="px-6 py-2 rounded-xl bg-red-600 hover:bg-red-700 text-white font-semibold mt-4">Reset Game</button>
  </div>
</section>

<!-- Footer -->
<footer class="py-6 sm:py-8 border-t border-gray-800 text-center text-gray-400 text-sm sm:text-base">
  <p>&copy; 2025 WaryWEB. All Rights Reserved.</p>
</footer>

<script>
  // --- Global Clock + Date ---
  function updateTime() {
    const now = new Date();
    const hours = String(now.getHours()).padStart(2, '0');
    const minutes = String(now.getMinutes()).padStart(2, '0');
    document.getElementById('clock').textContent = `${hours}:${minutes}`;
    document.getElementById('mobile-clock').textContent = `${hours}:${minutes}`;
    document.getElementById('mobile-time-small').textContent = `${hours}:${minutes}`;
    const month = now.toLocaleString('default', { month: 'short' });
    const dateText = `${month}, ${now.getFullYear()}`;
    document.getElementById('date').textContent = dateText;
    document.getElementById('mobile-date').textContent = dateText;
    document.getElementById('mobile-date-small').textContent = dateText;
  }
  updateTime();
  setInterval(updateTime, 60000);

  // Mobile menu toggle
  document.getElementById('mobile-menu-button').addEventListener('click', () => {
    document.getElementById('mobile-menu').classList.add('active');
  });
  document.getElementById('close-menu').addEventListener('click', () => {
    document.getElementById('mobile-menu').classList.remove('active');
  });

  // --- Reversi Game Logic ---
  const boardSize = 8;
  const gameBoardEl = document.getElementById('game-board');
  const messageEl = document.getElementById('game-message');
  const blackScoreEl = document.getElementById('black-score');
  const whiteScoreEl = document.getElementById('white-score');
  const pvpModeBtn = document.getElementById('pvp-mode');
  const aiModeBtn = document.getElementById('ai-mode');
  const easyModeBtn = document.getElementById('easy-mode-btn');
  const hardModeBtn = document.getElementById('hard-mode-btn');
  const resetBtn = document.getElementById('reset-button');
  const difficultyOptions = document.getElementById('difficulty-options');
  const hintOption = document.getElementById('hint-option');
  const hintToggle = document.getElementById('hint-toggle');

  // Game state variables
  const BLACK = 1;
  const WHITE = 2;
  const EMPTY = 0;

  let board = [];
  let currentPlayer = BLACK;
  let gameActive = false;
  let gameMode = 'pvp'; // 'ai' or 'pvp'
  let difficulty = 'hard'; // 'easy' or 'hard'
  let showHint = false;
  let aiThinking = false;

  // Directions for checking valid moves and flipping
  const directions = [
      [-1, -1], [-1, 0], [-1, 1],
      [0, -1],           [0, 1],
      [1, -1], [1, 0], [1, 1]
  ];

  /**
   * Initializes the game state.
   */
  function initGame() {
      board = Array.from({ length: boardSize }, () => Array(boardSize).fill(EMPTY));
      board[3][3] = WHITE;
      board[3][4] = BLACK;
      board[4][3] = BLACK;
      board[4][4] = WHITE;
      currentPlayer = BLACK;
      gameActive = true;
      aiThinking = false;
      startTurn();
  }

  /**
   * Updates the game message in the UI.
   * @param {string} msg The message to display.
   */
  function updateMessage(msg) {
      messageEl.textContent = msg;
  }

  /**
   * Renders the board and updates disc placement.
   */
  function renderBoard() {
      gameBoardEl.innerHTML = '';
      const validMoves = getValidMoves(currentPlayer);
      let bestMoveHint = null;

      if (gameMode === 'pvp' && showHint) {
          bestMoveHint = findHardAIMove();
      }

      for (let r = 0; r < boardSize; r++) {
          for (let c = 0; c < boardSize; c++) {
              const cell = document.createElement('div');
              cell.className = 'grid-cell';
              cell.dataset.row = r;
              cell.dataset.col = c;

              if (board[r][c] !== EMPTY) {
                  const disc = document.createElement('div');
                  disc.className = `disc ${board[r][c] === BLACK ? 'black' : 'white'}`;
                  cell.appendChild(disc);
                  cell.classList.add('occupied');
              } else if (validMoves.some(move => move[0] === r && move[1] === c)) {
                  // Add a hint for valid moves
                  cell.classList.add('hint');
                  cell.onclick = () => handleMove(r, c);

                  // Add hard AI hint if enabled
                  if (bestMoveHint && bestMoveHint[0] === r && bestMoveHint[1] === c) {
                      cell.classList.add('hint-hard');
                  }
              } else {
                  cell.classList.add('disabled');
              }

              gameBoardEl.appendChild(cell);
          }
      }
  }

  /**
   * Gets all valid moves for the current player.
   * @param {number} player The current player.
   * @returns {Array<Array<number>>} An array of valid move coordinates [row, col].
   */
  function getValidMoves(player) {
      const moves = [];
      for (let r = 0; r < boardSize; r++) {
          for (let c = 0; c < boardSize; c++) {
              if (board[r][c] === EMPTY && isValidMove(r, c, player)) {
                  moves.push([r, c]);
              }
          }
      }
      return moves;
  }

  /**
   * Checks if a move is valid for a given player.
   * @param {number} r The row to check.
   * @param {number} c The column to check.
   * @param {number} player The player making the move.
   * @returns {boolean} True if the move is valid, false otherwise.
   */
  function isValidMove(r, c, player) {
      if (board[r][c] !== EMPTY) {
          return false;
      }

      const opponent = player === BLACK ? WHITE : BLACK;

      for (const [dr, dc] of directions) {
          let foundOpponent = false;
          let currentR = r + dr;
          let currentC = c + dc;

          while (currentR >= 0 && currentR < boardSize && currentC >= 0 && currentC < boardSize) {
              if (board[currentR][currentC] === opponent) {
                  foundOpponent = true;
              } else if (board[currentR][currentC] === player) {
                  if (foundOpponent) {
                      return true; // Found a sandwich
                  }
                  break; // No opponent discs found to sandwich
              } else {
                  break; // Empty cell or end of board
              }
              currentR += dr;
              currentC += dc;
          }
      }
      return false;
  }

  /**
   * Flips discs on the board after a valid move.
   * @param {number} r The row of the new disc.
   * @param {number} c The column of the new disc.
   * @param {number} player The player who made the move.
   */
  function flipDiscs(r, c, player) {
      const discsToFlip = [];
      const opponent = player === BLACK ? WHITE : BLACK;

      for (const [dr, dc] of directions) {
          const lineToFlip = [];
          let currentR = r + dr;
          let currentC = c + dc;

          while (currentR >= 0 && currentR < boardSize && currentC >= 0 && currentC < boardSize) {
              if (board[currentR][currentC] === opponent) {
                  lineToFlip.push([currentR, currentC]);
              } else if (board[currentR][currentC] === player) {
                  discsToFlip.push(...lineToFlip);
                  break;
              } else {
                  break;
              }
              currentR += dr;
              currentC += dc;
          }
      }

      if (discsToFlip.length > 0) {
          board[r][c] = player;
          discsToFlip.forEach(([flipR, flipC]) => {
              board[flipR][flipC] = player;
          });
      }
  }

  /**
   * Main function to handle a move from a player.
   * @param {number} r The row of the move.
   * @param {number} c The column of the move.
   */
  function handleMove(r, c) {
      if (!gameActive || aiThinking) {
          return;
      }

      if (isValidMove(r, c, currentPlayer)) {
          flipDiscs(r, c, currentPlayer);
          currentPlayer = currentPlayer === BLACK ? WHITE : BLACK;
          startTurn();
      } else {
          // This case should not be reached if hints are used
          updateMessage("Invalid move. Please choose a highlighted cell.");
      }
  }

  /**
   * Starts the turn for the current player, handling game logic and AI.
   */
  function startTurn() {
      updateScore();
      renderBoard();

      const validMovesForCurrent = getValidMoves(currentPlayer);

      if (validMovesForCurrent.length === 0) {
          // Check for game end condition
          const validMovesForOpponent = getValidMoves(currentPlayer === BLACK ? WHITE : BLACK);
          if (validMovesForOpponent.length === 0) {
              endGame();
              return;
          } else {
              // Pass turn to opponent as current player has no moves
              updateMessage(`${currentPlayer === BLACK ? 'Black' : 'White'} has no moves. Passing turn.`);
              currentPlayer = currentPlayer === BLACK ? WHITE : BLACK;
              setTimeout(startTurn, 1500); // 1.5 second delay before next turn
              return;
          }
      }

      // Announce whose turn it is
      updateMessage(`${currentPlayer === BLACK ? 'Black' : 'White'}'s turn.`);

      // Handle AI turn if in AI mode
      if (gameMode === 'ai' && currentPlayer === WHITE) {
          handleAITurn();
      }
  }

  /**
   * Updates the score in the UI.
   */
  function updateScore() {
      const blackCount = board.flat().filter(cell => cell === BLACK).length;
      const whiteCount = board.flat().filter(cell => cell === WHITE).length;
      blackScoreEl.textContent = blackCount;
      whiteScoreEl.textContent = whiteCount;
  }

  /**
   * Ends the game and displays the winner.
   */
  function endGame() {
      gameActive = false;
      const blackCount = board.flat().filter(cell => cell === BLACK).length;
      const whiteCount = board.flat().filter(cell => cell === WHITE).length;
      if (blackCount > whiteCount) {
          updateMessage("Game Over! Black wins!");
      } else if (whiteCount > blackCount) {
          updateMessage("Game Over! White wins!");
      } else {
          updateMessage("Game Over! It's a tie!");
      }
      renderBoard(); // Render a final time without hints
  }

  /**
   * AI logic for Easy mode. Chooses a random valid move.
   * @returns {Array<number>} The coordinates of the move.
   */
  function findEasyAIMove() {
      const validMoves = getValidMoves(WHITE);
      if (validMoves.length === 0) return null;
      const randomIndex = Math.floor(Math.random() * validMoves.length);
      return validMoves[randomIndex];
  }

  /**
   * AI logic for Hard mode. Prioritizes corners, then most flips.
   * @returns {Array<number>} The coordinates of the best move.
   */
  function findHardAIMove() {
      const validMoves = getValidMoves(WHITE);
      if (validMoves.length === 0) return null;

      // Check for corner moves first (most strategic)
      const corners = [[0, 0], [0, 7], [7, 0], [7, 7]];
      const cornerMoves = validMoves.filter(move => corners.some(corner => corner[0] === move[0] && corner[1] === move[1]));
      if (cornerMoves.length > 0) {
          return cornerMoves[Math.floor(Math.random() * cornerMoves.length)];
      }

      // If no corner moves, use the "most flips" logic
      let bestMoves = [];
      let maxFlips = -1;

      for (const move of validMoves) {
          const flips = countFlips(move[0], move[1], WHITE);
          if (flips > maxFlips) {
              maxFlips = flips;
              bestMoves = [move];
          } else if (flips === maxFlips) {
              bestMoves.push(move);
          }
      }

      // Randomly choose from the list of best moves for a little variety
      const randomIndex = Math.floor(Math.random() * bestMoves.length);
      return bestMoves[randomIndex];
  }

  /**
   * Counts how many discs would be flipped by a move.
   * @param {number} r The row of the move.
   * @param {number} c The column of the move.
   * @param {number} player The player making the move.
   * @returns {number} The total number of discs flipped.
   */
  function countFlips(r, c, player) {
      let totalFlips = 0;
      const opponent = player === BLACK ? WHITE : BLACK;
      for (const [dr, dc] of directions) {
          let lineFlips = 0;
          let currentR = r + dr;
          let currentC = c + dc;
          while (currentR >= 0 && currentR < boardSize && currentC >= 0 && currentC < boardSize) {
              if (board[currentR][currentC] === opponent) {
                  lineFlips++;
              } else if (board[currentR][currentC] === player) {
                  totalFlips += lineFlips;
                  break;
              } else {
                  break;
              }
              currentR += dr;
              currentC += dc;
          }
      }
      return totalFlips;
  }

  /**
   * Handles the AI's turn.
   */
  function handleAITurn() {
      aiThinking = true;
      updateMessage("White (AI) is thinking...");

      let aiMove;
      if (difficulty === 'hard') {
          aiMove = findHardAIMove();
      } else {
          aiMove = findEasyAIMove();
      }

      if (aiMove) {
          const [r, c] = aiMove;
          // Find the cell to highlight
          const cellToHighlight = gameBoardEl.querySelector(`[data-row="${r}"][data-col="${c}"]`);
          if (cellToHighlight) {
              cellToHighlight.classList.add('ai-move-highlight');
          }

          // Wait 1.5 seconds for the user to see the highlight
          setTimeout(() => {
              if (cellToHighlight) {
                  cellToHighlight.classList.remove('ai-move-highlight');
              }
              aiThinking = false;
              handleMove(r, c);
          }, 1500);
      } else {
          // Pass the turn if no moves are available
          aiThinking = false;
          startTurn();
      }
  }

  /**
   * Sets the game mode.
   * @param {string} mode The game mode ('ai' or 'pvp').
   */
  function setGameMode(mode) {
      gameMode = mode;
      pvpModeBtn.classList.remove('bg-green-700', 'hover:bg-green-800');
      pvpModeBtn.classList.add('bg-green-600', 'hover:bg-green-700');
      aiModeBtn.classList.remove('bg-purple-700', 'hover:bg-purple-800');
      aiModeBtn.classList.add('bg-purple-600', 'hover:bg-purple-700');

      if (mode === 'pvp') {
          pvpModeBtn.classList.remove('bg-green-600');
          pvpModeBtn.classList.add('bg-green-700');
          difficultyOptions.classList.add('hidden');
          hintOption.classList.remove('hidden');
      } else {
          aiModeBtn.classList.remove('bg-purple-600');
          aiModeBtn.classList.add('bg-purple-700');
          difficultyOptions.classList.remove('hidden');
          hintOption.classList.add('hidden');
      }
      initGame();
  }

  /**
   * Sets the AI difficulty.
   * @param {string} mode The difficulty mode ('easy' or 'hard').
   */
  function setDifficulty(mode) {
      difficulty = mode;
      easyModeBtn.classList.remove('bg-gray-700', 'hover:bg-gray-800');
      easyModeBtn.classList.add('bg-gray-600', 'hover:bg-gray-700');
      hardModeBtn.classList.remove('bg-red-700', 'hover:bg-red-800');
      hardModeBtn.classList.add('bg-red-600', 'hover:bg-red-700');
      if (mode === 'easy') {
          easyModeBtn.classList.remove('bg-gray-600');
          easyModeBtn.classList.add('bg-gray-700');
      } else {
          hardModeBtn.classList.remove('bg-red-600');
          hardModeBtn.classList.add('bg-red-700');
      }
      initGame();
  }

  // Event listeners for mode selection, difficulty, hint toggle, and reset
  pvpModeBtn.addEventListener('click', () => setGameMode('pvp'));
  aiModeBtn.addEventListener('click', () => setGameMode('ai'));
  easyModeBtn.addEventListener('click', () => setDifficulty('easy'));
  hardModeBtn.addEventListener('click', () => setDifficulty('hard'));
  resetBtn.addEventListener('click', initGame);

  hintToggle.addEventListener('change', (e) => {
      showHint = e.target.checked;
      renderBoard(); // Re-render the board to show/hide the hint
  });

  // Initial game setup
  window.onload = function() {
      setGameMode('pvp'); // Start in PvP mode by default
      setDifficulty('hard'); // Hard difficulty by default for AI mode
  };
</script>
</body>
</html>
